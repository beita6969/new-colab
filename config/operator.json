{
  "Custom": {
    "description": "Generates anything based on customized input and instruction.",
    "interface": "custom(input: str, instruction: str) -> dict with key 'response'"
  },
  "AnswerGenerate": {
    "description": "Generates step-by-step reasoning with thought process and final answer.",
    "interface": "answer_generate(input: str) -> dict with keys 'thought' and 'answer'"
  },
  "CustomCodeGenerate": {
    "description": "Generates code based on customized input and instruction.",
    "interface": "custom_code_generate(problem: str, entry_point: str, instruction: str) -> dict with key 'code'"
  },
  "Programmer": {
    "description": "Automatically writes and executes Python code, returns execution result.",
    "interface": "programmer(problem: str, analysis: str = 'None') -> dict with keys 'code' (source) and 'output' (RESULT - always use this!)"
  },
  "Test": {
    "description": "Tests code with test cases, reflects on errors and revises.",
    "interface": "test(problem: str, solution: str, entry_point: str, test_loop: int = 3) -> dict with keys 'result' (bool) and 'solution'"
  },
  "Format": {
    "description": "Extracts concise answer from verbose solution.",
    "interface": "format(problem: str, solution: str) -> dict with key 'solution'"
  },
  "Review": {
    "description": "Reviews solution correctness using critical thinking.",
    "interface": "review(problem: str, solution: str) -> dict with keys 'review_result' (bool) and 'feedback'"
  },
  "Revise": {
    "description": "Revises solution based on feedback.",
    "interface": "revise(problem: str, solution: str, feedback: str) -> dict with key 'solution'"
  },
  "ScEnsemble": {
    "description": "Uses self-consistency to select the most frequent solution.",
    "interface": "sc_ensemble(solutions: List[str], problem: str) -> dict with key 'response'"
  },
  "MdEnsemble": {
    "description": "Majority voting ensemble - shuffles and votes multiple times (more robust than ScEnsemble).",
    "interface": "md_ensemble(solutions: List[str], problem: str) -> dict with key 'solution'"
  }
}
